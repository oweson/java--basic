package basic.pond.basic;

/**
 * the class is create by @Author:oweson
 *
 * @Date：2018/11/22 0022 10:23
 */
public class Demo8InterfaceAndExtends {

    public void sleep() {
        System.out.println("老子");
    }

    public static void main(String[] args) {
        /** 1 引用类型和对象类型是一样的
         接下来要讨论的类型转换的问题，指的是引用类型和对象类型不一致的情况下的转换问题*/
        /** 2 没有继承关系的两个类，互相转换，一定会失败
         虽然ADHero和APHero都继承了Hero，但是彼此没有互相继承关系*/
        /** 3 子类可以继承父类的对象方法

         在继承后，重复提供该方法，就叫做方法的重写

         又叫覆盖 override*/
        /** 4 操作符的多态
         同一个操作符在不同情境下，具备不同的作用
         如果+号两侧都是整型，那么+代表 数字相加
         如果+号两侧，任意一个是字符串，那么+代表字符串连接*/
        /** 5 观察类的多态现象：
         1. i1和i2都是Item类型
         2. 都调用effect方法
         3. 输出不同的结果

         多态: 都是同一个类型，调用同一个方法，却能呈现不同的状态*/
        /** 6  类的多态条件
         要实现类的多态，需要如下条件
         1. 父类（接口）引用指向子类对象
         2. 调用的方法有重写*/
        /**7 重写类似，方法的重写是子类覆盖父类的对象方法

         隐藏，就是子类覆盖父类的类方法*/
        /** 8 虽然隐藏了但是父类引用调用的就是父类的方法 */
        new Demo8InterfaceAndExtends().sleep();
        /** 9 实例化一个ADHero(), 其构造方法会被调用
         其父类的构造方法也会被调用
         并且是父类构造方法先调用
         子类构造方法会默认调用父类的 无参的构造方法.如果无参数的不存在，就会异常，
         或者显示的调用父类的有参数的方法；
         子类显式调用父类带参构造方法 顶 折 纠 问
         使用关键字super 显式调用父类带参的构造方法第一行！！！*/
        /**10 调用父类属性 顶 折 纠 问
         通过super调用父类的moveSpeed属性
         ADHero也提供了属性moveSpeed*/
        /** 11 Object类提供一个toString方法，所以所有的类都有toString方法
         toString()的意思是返回当前对象的字符串表达
         通过 System.out.println 打印对象就是打印该对象的toString()返回值*/
        /**12 finalize() 顶 折 纠 问
         当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件

         当它被垃圾回收的时候，它的finalize() 方法就会被调用。

         finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的。*/
        /** 13 final修饰方法 顶 折 纠 问
         Hero的useItem方法被修饰成final,那么该方法在ADHero中，不能够被重写;
         final修饰基本类型变量，表示该变量只有一次赋值机会
         16行进行了赋值，17行就不可以再进行赋值了;
         final修饰引用
         h引用被修饰成final，表示该引用只有1次指向对象的机会
         所以17行会出现编译错误
         但是，依然通过h引用修改对象的属性值hp，因为hp并没有final修饰*/
        /** 17 子类只能继承一个抽象类，不能继承多个
         子类可以实现多个接口
         区别2：
         抽象类可以定义
         public,protected,package,private
         静态和非静态属性
         final和非final属性
         但是接口中声明的属性，只能是
         public
         静态
         final的
         即便没有显式的声明

         注: 抽象类和接口都可以有实体方法。 接口中的实体方法，叫做默认方法*/
        /** 18 匿名类 顶 折 纠 问
         匿名类指的是在声明一个类的同时实例化它，使代码更加简洁精练
         通常情况下，要使用一个接口或者抽象类，都必须创建一个子类

         有的时候，为了快速使用，直接实例化一个抽象类，并“当场”实现其抽象方法。
         既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。
         这样的类，叫做匿名类;
         本地类可以理解为有名字的匿名类
         与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。
         本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方*/
        //与匿名类的区别在于，本地类有了自定义的类名
        /** 19 //在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final*/
        /** 20 Mortal 这个接口，增加了一个默认方法 revive，这个方法有实现体，并且被声明为了default
         假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动。

         但是引入了默认方法后，原来的类，不需要做任何改动，并且还能得到这个默认方法

         通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类*/
        /** 21 */
    }
}

class Ppx extends Demo8InterfaceAndExtends {
    @Override
    public void sleep() {
        System.out.println("son");
    }
}
