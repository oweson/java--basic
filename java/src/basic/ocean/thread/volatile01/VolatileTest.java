package basic.ocean.thread.volatile01;

/**
 * the class is create by @Author:oweson
 *
 * @Date：2019/1/10 0010 14:25
 */
public class VolatileTest {
    /**
     * 在多线程环境下，某个共享变量如果被其中一个线程给修改了，
     * 其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，
     * 最终会去内存中读取，而不是从自己的工作空间中读取。
     * 例如我们上面说的，当线程1对t进行了加1操作并把数据写回到主存之后，
     * 线程2就会知道它自己工作空间内的t已经被修改了，当它要执行加1操作之后，
     * 就会去主存中读取。这样，两边的数据就能一致了。
     * 假如一个变量被声明为volatile，那么这个变量就具有了可见性的性质了。
     * 这就是volatile关键的作用之一了。
     */
    public static volatile int a = 100;

    /**
     *  1 第一：保证在内存的可见性，第二：防止指令的重排；
     *
     */
    /** 2 有序性;
     实际上，当我们把代码写好之后，虚拟机不一定会按照我们写的代码的顺序来执行。例如对于下面的两句代码：

     int a = 1;
     int b = 2;
     对于这两句代码，你会发现无论是先执行a = 1还是执行b = 2，都不会对a,b最终的值造成影响。
     所以虚拟机在编译的时候，是有可能把他们进行重排序的。
     为什么要进行重排序呢？
     你想啊，假如执行 int a = 1这句代码需要100ms的时间，但执行int b = 2这句代码需要1ms的时间，
     并且先执行哪句代码并不会对a,b最终的值造成影响。那当然是先执行int b = 2这句代码了。
     所以，虚拟机在进行代码编译优化的时候，对于那些改变顺序之后不会对最终变量的值造成影响的代码，
     是有可能将他们进行重排序的。*/
    /**
     * 3 缓存一致性协议：说“如果一个共享变量被一个线程修改了之后，
     * 当其他线程要读取这个变量的时候，最终会去内存中读取，
     * 而不是从自己的工作空间中读取”，实际上是这样的：
     * 线程中的处理器会一直在总线上嗅探其内部缓存中的内存地址在其他处理器的操作情况，
     * 一旦嗅探到某处处理器打算修改其内存地址中的值，而该内存地址刚好也在自己的内部缓存中，
     * 那么处理器就会强制让自己对该缓存地址的无效。所以当该处理器要访问该数据的时候，
     * 由于发现自己缓存的数据无效了，就会去主存中访问。
     */
    /**
     * 4 volatile保证变量可见性的原理
     */
    public static void main(String[] args) {
        a++;
        ++a;
        System.out.println(a);

    }
}
