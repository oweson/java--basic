#Java中什么是序列化？

 序列化，又称为“串化”，可以形象的把它理解为把Java对象内存中的数据采编成一串二进制的数据，然后把这些数据存放在可以可以持久化的数据设备上，如磁盘。
 当需要还原这些数据的时候，在通过反序列化的过程，把对象又重新还原到内存中。
 
 序列化本质上就是把对象内存中的数据按照一定规则，变成一系列的字节数据，然后在把这些字节数据写入到流中。而反序列化的过程相反，先读取字节数据，然后在重新组装成Java对象。

 ##为什么需要序列化?
 1. 一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。
 2. 需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。

 ##Java
 1. Java 提供自动序列化，需要以java.io.Serializable接口的实例来标明对象。
 实作接口将类别标明为“可序列化”，然后Java在内部处理序列化。在Serializable界面上并没有预先定义序列化的方法，但可序列化类别可任意定义某些特定名称和签署的方法，如果这些方法有定义了，可被调用执行序列化/反序列化部分过程。该语言允许开发人员以另一个Externalizable界面，更彻底地实作并覆盖序列化过程，这个界面包括了保存和恢复物件状态的两种特殊方法。
 
 2. 在预设情况下有三个主要原因使物件无法被序列化。其一，在序列化状态下并不是所有的物件都能获取到有用的语义。例如，Thread物件绑定到当前Java虚拟机的状态，对Thread物件状态的反序列化环境来说，没有意义。其二，物件的序列化状态构成其类别相容性缔结（compatibility contract）的某一部分。在维护可序列化类别之间的相容性时，需要额外的精力和考量。所以，使类别可序列化需要慎重的设计决策而非预设情况。其三，序列化允许存取类别的永久私有成员，包含敏感资讯（例如，密码）的类别不应该是可序列化的，也不能外部化。上述三种情形，必须实作Serializable界面来存取Java内部的序列化机制。标准的编码方法将字段简单转换为字节流。
 
 3. 原生型别以及永久和非静态的物件参照，会被编码到字节流之中。序列化物件参照的每个物件，若其中未标明为transient的字段，也必须被序列化；如果整个过程中，参照到的任何永久物件不能序列化，则这个过程会失败。开发人员可将物件标记为暂时的，或针对物件重新定义的序列化，来影响序列化的处理过程，以截断参照图的某些部分而不序列化。Java并不使用构造函数来序列化对象。
 
 4. 由JDBC也可对Java物件进行序列化，并将其储存到数据库中。虽然Swing元件的确实例化了Serializable接口，但它们不能移植到有版本差异的Java虚拟机之间。因此，Swing元件或任何继承它的元件可以序列化为字节阵列，但不能保证这个仓存在另一台机器上可读取。